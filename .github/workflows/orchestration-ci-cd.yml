name: Orchestration CI/CD

on:
  push:
    branches:
      - dev
      - stage
      - main
  pull_request:
    types:
      - opened
      - synchronize
      - reopened
      - ready_for_review
    branches:
      - dev
      - stage
      - main
  workflow_dispatch:

concurrency:
  group: orchestration-${{ github.ref }}
  cancel-in-progress: true

jobs:
  lane_policy:
    name: Lane Promotion Policy
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        if: github.event_name == 'pull_request'
        uses: actions/checkout@v4

      - name: Enforce branch promotion lanes
        if: github.event_name == 'pull_request'
        run: bash .github/scripts/check_promotion_lane.sh

      - name: Skip lane policy on non-PR events
        if: github.event_name != 'pull_request'
        run: |
          echo "SKIP: lane policy is only enforced for pull_request events."

  preflight:
    name: Preflight Validation
    runs-on: ubuntu-latest
    needs:
      - lane_policy
    if: ${{ github.event_name != 'pull_request' || needs.lane_policy.result == 'success' }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Determine lane branch
        id: lane
        run: |
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            echo "branch=${{ github.base_ref }}" >> "$GITHUB_OUTPUT"
          else
            echo "branch=${{ github.ref_name }}" >> "$GITHUB_OUTPUT"
          fi

      - name: Resolve submodule checkout auth
        id: submodule_auth
        env:
          SUBMODULES_REPO_TOKEN: ${{ secrets.SUBMODULES_REPO_TOKEN }}
          WEB_APP_REPO_TOKEN: ${{ secrets.WEB_APP_REPO_TOKEN }}
        run: |
          token="${SUBMODULES_REPO_TOKEN:-}"
          if [[ -z "$token" ]]; then
            token="${WEB_APP_REPO_TOKEN:-}"
          fi

          if [[ -n "$token" ]]; then
            echo "::add-mask::$token"
            echo "has_token=true" >> "$GITHUB_OUTPUT"
            echo "token=$token" >> "$GITHUB_OUTPUT"
          else
            echo "has_token=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Checkout submodules
        if: steps.submodule_auth.outputs.has_token == 'true'
        env:
          SUBMODULE_TOKEN: ${{ steps.submodule_auth.outputs.token }}
        run: |
          git config --global --unset-all url.https://github.com/.insteadOf || true
          git config --global url."https://x-access-token:${SUBMODULE_TOKEN}@github.com/".insteadOf "https://github.com/"
          git submodule sync --recursive
          git submodule update --init --recursive

      - name: Fail when missing submodule token
        if: steps.submodule_auth.outputs.has_token != 'true'
        run: |
          echo "ERROR: missing required secret for private submodule checkout." >&2
          echo "Set SUBMODULES_REPO_TOKEN (recommended) or WEB_APP_REPO_TOKEN in this repository secrets." >&2
          exit 1

      - name: Verify environment invariants
        run: bash .github/scripts/verify_environment_ci.sh

      - name: Validate submodule lane alignment
        env:
          GH_TOKEN: ${{ steps.submodule_auth.outputs.token }}
        run: bash .github/scripts/check_submodule_branch_alignment.sh "${{ steps.lane.outputs.branch }}"

      - name: Validate web/flutter metadata compatibility
        run: bash .github/scripts/check_web_flutter_metadata.sh "${{ steps.lane.outputs.branch }}"

      - name: Validate pinned submodule SHA CI status (promotion PRs)
        if: ${{ github.event_name == 'pull_request' && (github.base_ref == 'stage' || github.base_ref == 'main') }}
        env:
          GH_TOKEN: ${{ steps.submodule_auth.outputs.token }}
        run: bash .github/scripts/check_submodule_sha_ci_green.sh

      - name: Prepare source promotion PRs (exact SHA, no auto-merge)
        if: ${{ always() && github.event_name == 'pull_request' && (github.base_ref == 'stage' || github.base_ref == 'main') }}
        env:
          GH_TOKEN: ${{ steps.submodule_auth.outputs.token }}
        run: bash .github/scripts/prepare_source_promotion_prs.sh

      - name: Validate source promotion PRs are merge-ready
        if: ${{ github.event_name == 'pull_request' && (github.base_ref == 'stage' || github.base_ref == 'main') }}
        env:
          GH_TOKEN: ${{ steps.submodule_auth.outputs.token }}
        run: bash .github/scripts/check_source_promotion_prs_ready.sh

  promote_source_repos:
    name: Promote Source Repos (Post-Merge)
    runs-on: ubuntu-latest
    needs:
      - preflight
    if: ${{ github.event_name == 'push' && (github.ref_name == 'stage' || github.ref_name == 'main') && needs.preflight.result == 'success' }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Resolve submodule checkout auth
        id: submodule_auth
        env:
          SUBMODULES_REPO_TOKEN: ${{ secrets.SUBMODULES_REPO_TOKEN }}
          WEB_APP_REPO_TOKEN: ${{ secrets.WEB_APP_REPO_TOKEN }}
        run: |
          token="${SUBMODULES_REPO_TOKEN:-}"
          if [[ -z "$token" ]]; then
            token="${WEB_APP_REPO_TOKEN:-}"
          fi

          if [[ -n "$token" ]]; then
            echo "::add-mask::$token"
            echo "has_token=true" >> "$GITHUB_OUTPUT"
            echo "token=$token" >> "$GITHUB_OUTPUT"
          else
            echo "has_token=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Checkout submodules
        if: steps.submodule_auth.outputs.has_token == 'true'
        env:
          SUBMODULE_TOKEN: ${{ steps.submodule_auth.outputs.token }}
        run: |
          git config --global --unset-all url.https://github.com/.insteadOf || true
          git config --global url."https://x-access-token:${SUBMODULE_TOKEN}@github.com/".insteadOf "https://github.com/"
          git submodule sync --recursive
          git submodule update --init --recursive

      - name: Fail when missing submodule token
        if: steps.submodule_auth.outputs.has_token != 'true'
        run: |
          echo "ERROR: missing required secret for private submodule checkout." >&2
          echo "Set SUBMODULES_REPO_TOKEN (recommended) or WEB_APP_REPO_TOKEN in this repository secrets." >&2
          exit 1

      - name: Execute source promotion merges (exact SHA + green checks)
        env:
          GH_TOKEN: ${{ steps.submodule_auth.outputs.token }}
        run: bash .github/scripts/merge_source_promotion_prs.sh

  deploy_stage:
    name: Deploy Stage
    runs-on: ubuntu-latest
    needs:
      - preflight
      - promote_source_repos
    if: ${{ github.event_name == 'push' && github.ref_name == 'stage' && needs.preflight.result == 'success' && needs.promote_source_repos.result == 'success' }}
    environment: stage

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Resolve submodule checkout auth
        id: submodule_auth
        env:
          SUBMODULES_REPO_TOKEN: ${{ secrets.SUBMODULES_REPO_TOKEN }}
          WEB_APP_REPO_TOKEN: ${{ secrets.WEB_APP_REPO_TOKEN }}
        run: |
          token="${SUBMODULES_REPO_TOKEN:-}"
          if [[ -z "$token" ]]; then
            token="${WEB_APP_REPO_TOKEN:-}"
          fi

          if [[ -n "$token" ]]; then
            echo "::add-mask::$token"
            echo "has_token=true" >> "$GITHUB_OUTPUT"
            echo "token=$token" >> "$GITHUB_OUTPUT"
          else
            echo "has_token=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Checkout submodules
        if: steps.submodule_auth.outputs.has_token == 'true'
        env:
          SUBMODULE_TOKEN: ${{ steps.submodule_auth.outputs.token }}
        run: |
          git config --global --unset-all url.https://github.com/.insteadOf || true
          git config --global url."https://x-access-token:${SUBMODULE_TOKEN}@github.com/".insteadOf "https://github.com/"
          git submodule sync --recursive
          git submodule update --init --recursive

      - name: Fail when missing submodule token
        if: steps.submodule_auth.outputs.has_token != 'true'
        run: |
          echo "ERROR: missing required secret for private submodule checkout." >&2
          echo "Set SUBMODULES_REPO_TOKEN (recommended) or WEB_APP_REPO_TOKEN in this repository secrets." >&2
          exit 1

      - name: Configure SSH private key
        env:
          STAGE_SSH_PRIVATE_KEY: ${{ secrets.STAGE_SSH_PRIVATE_KEY }}
        run: |
          if [[ -z "${STAGE_SSH_PRIVATE_KEY:-}" ]]; then
            echo "ERROR: missing required secret STAGE_SSH_PRIVATE_KEY." >&2
            exit 1
          fi

          install -m 700 -d ~/.ssh
          printf '%s\n' "$STAGE_SSH_PRIVATE_KEY" > ~/.ssh/id_ed25519_stage
          chmod 600 ~/.ssh/id_ed25519_stage

      - name: Configure known hosts
        env:
          STAGE_SSH_KNOWN_HOSTS: ${{ secrets.STAGE_SSH_KNOWN_HOSTS }}
        run: |
          if [[ -z "${STAGE_SSH_KNOWN_HOSTS:-}" ]]; then
            echo "ERROR: missing required secret STAGE_SSH_KNOWN_HOSTS." >&2
            exit 1
          fi

          install -m 700 -d ~/.ssh
          printf '%s\n' "$STAGE_SSH_KNOWN_HOSTS" > ~/.ssh/known_hosts
          chmod 600 ~/.ssh/known_hosts

      - name: Capture stage rollback target revision
        id: stage_rollback_target
        env:
          DEPLOY_SSH_HOST: ${{ vars.STAGE_SSH_HOST }}
          DEPLOY_SSH_PORT: ${{ vars.STAGE_SSH_PORT }}
          DEPLOY_SSH_USER: ${{ vars.STAGE_SSH_USER }}
          DEPLOY_PATH: ${{ vars.STAGE_DEPLOY_PATH }}
          DEPLOY_SSH_KEY_PATH: ~/.ssh/id_ed25519_stage
        run: |
          set -euo pipefail

          target="$(
            ssh -p "${DEPLOY_SSH_PORT}" -i "${DEPLOY_SSH_KEY_PATH}" \
              -o BatchMode=yes -o IdentitiesOnly=yes -o StrictHostKeyChecking=yes \
              "${DEPLOY_SSH_USER}@${DEPLOY_SSH_HOST}" "set -euo pipefail; if [[ -d '${DEPLOY_PATH}/.git' ]]; then cd '${DEPLOY_PATH}'; if [[ -f '.last_successful_revision' ]]; then cat '.last_successful_revision'; elif git rev-parse --verify HEAD >/dev/null 2>&1; then git rev-parse HEAD; fi; fi"
          )"

          target="$(echo "$target" | tr -d '[:space:]')"
          if [[ -n "$target" ]]; then
            echo "revision=$target" >> "$GITHUB_OUTPUT"
            echo "INFO: stage rollback target revision captured: $target"
          else
            echo "INFO: stage rollback target revision unavailable (first deployment path or no git HEAD)."
          fi

      - name: Deploy pinned stage stack over SSH
        env:
          DEPLOY_LANE: stage
          DEPLOY_SSH_HOST: ${{ vars.STAGE_SSH_HOST }}
          DEPLOY_SSH_PORT: ${{ vars.STAGE_SSH_PORT }}
          DEPLOY_SSH_USER: ${{ vars.STAGE_SSH_USER }}
          DEPLOY_PATH: ${{ vars.STAGE_DEPLOY_PATH }}
          DEPLOY_NGINX_HOST_PORT_80: ${{ vars.STAGE_NGINX_HOST_PORT_80 }}
          DEPLOY_NGINX_HOST_PORT_443: ${{ vars.STAGE_NGINX_HOST_PORT_443 }}
          DEPLOY_HEALTH_HOST: ${{ vars.STAGE_NAV_LANDLORD_URL }}
          DEPLOY_SSH_KEY_PATH: ~/.ssh/id_ed25519_stage
          SUBMODULES_REPO_TOKEN: ${{ steps.submodule_auth.outputs.token }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          GITHUB_REF_NAME: ${{ github.ref_name }}
        run: bash .github/scripts/deploy_stage_over_ssh.sh

      - name: Validate stage navigation targets configuration
        run: |
          if [[ -z "${{ vars.STAGE_NAV_LANDLORD_URL }}" || -z "${{ vars.STAGE_NAV_TENANT_URL }}" ]]; then
            echo "ERROR: missing stage navigation variables STAGE_NAV_LANDLORD_URL/STAGE_NAV_TENANT_URL." >&2
            exit 1
          fi

      - name: Preflight stage initialization status
        id: stage_initialize_preflight
        env:
          NAV_LANDLORD_URL: ${{ vars.STAGE_NAV_LANDLORD_URL }}
          NAV_ORIGIN_IP: ${{ vars.STAGE_SSH_HOST }}
        run: |
          set -euo pipefail

          landlord="${NAV_LANDLORD_URL%/}"
          initialize_url="${landlord}/api/v1/initialize"
          landlord_host="$(python3 -c 'import sys, urllib.parse; print((urllib.parse.urlparse(sys.argv[1]).hostname or "").strip())' "$landlord")"
          if [[ -z "$landlord_host" ]]; then
            echo "ERROR: could not parse stage landlord host from NAV_LANDLORD_URL." >&2
            exit 1
          fi

          curl_args=()
          if [[ -n "${NAV_ORIGIN_IP:-}" ]]; then
            curl_args+=(--resolve "${landlord_host}:443:${NAV_ORIGIN_IP}")
            curl_args+=(--insecure)
            echo "INFO: stage initialization preflight routed directly to origin ${NAV_ORIGIN_IP}."
          fi

          echo "INFO: checking stage initialization status at ${initialize_url}"
          status="$(curl -sS -m 15 "${curl_args[@]}" -o /tmp/stage_initialize_response.json -w '%{http_code}' "${initialize_url}")"

          case "${status}" in
            200)
              echo "initialized=true" >> "$GITHUB_OUTPUT"
              ;;
            403)
              echo "initialized=false" >> "$GITHUB_OUTPUT"
              echo "::warning title=Stage not initialized::Skipping navigation smoke because /api/v1/initialize returned HTTP 403."
              cat /tmp/stage_initialize_response.json || true
              ;;
            *)
              echo "ERROR: unexpected stage initialization status ${status}. Expected 200 or 403." >&2
              cat /tmp/stage_initialize_response.json >&2 || true
              exit 1
              ;;
          esac

      - name: Skip stage navigation smoke (environment not initialized)
        if: steps.stage_initialize_preflight.outputs.initialized != 'true'
        run: |
          echo "INFO: skipping stage navigation smoke because environment is not initialized yet."

      - name: Setup Node.js for real navigation smoke
        if: steps.stage_initialize_preflight.outputs.initialized == 'true'
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: npm
          cache-dependency-path: web-app/package-lock.json

      - name: Install web navigation dependencies
        if: steps.stage_initialize_preflight.outputs.initialized == 'true'
        run: npm ci
        working-directory: web-app

      - name: Install Playwright browser
        if: steps.stage_initialize_preflight.outputs.initialized == 'true'
        run: npx playwright install --with-deps chromium
        working-directory: web-app

      - name: Route stage smoke hosts directly to origin
        if: steps.stage_initialize_preflight.outputs.initialized == 'true'
        env:
          NAV_LANDLORD_URL: ${{ vars.STAGE_NAV_LANDLORD_URL }}
          NAV_TENANT_URL: ${{ vars.STAGE_NAV_TENANT_URL }}
          NAV_ORIGIN_IP: ${{ vars.STAGE_SSH_HOST }}
        run: |
          set -euo pipefail

          parse_host() {
            local input_url="$1"
            python3 -c 'import sys, urllib.parse; print((urllib.parse.urlparse(sys.argv[1]).hostname or "").strip())' "$input_url"
          }

          landlord_host="$(parse_host "$NAV_LANDLORD_URL")"
          tenant_host="$(parse_host "$NAV_TENANT_URL")"

          if [[ -z "$landlord_host" || -z "$tenant_host" ]]; then
            echo "ERROR: could not parse stage landlord/tenant hosts from navigation URLs." >&2
            exit 1
          fi

          if [[ -n "${NAV_ORIGIN_IP:-}" ]]; then
            {
              echo "${NAV_ORIGIN_IP} ${landlord_host}"
              echo "${NAV_ORIGIN_IP} ${tenant_host}"
            } | sudo tee -a /etc/hosts >/dev/null
            echo "PLAYWRIGHT_IGNORE_HTTPS_ERRORS=true" >> "$GITHUB_ENV"
            echo "INFO: stage smoke mapped ${landlord_host}/${tenant_host} to ${NAV_ORIGIN_IP}."
          else
            echo "PLAYWRIGHT_IGNORE_HTTPS_ERRORS=false" >> "$GITHUB_ENV"
            echo "INFO: stage smoke using public DNS resolution."
          fi

      - name: Run stage real navigation smoke
        id: stage_navigation_smoke
        if: steps.stage_initialize_preflight.outputs.initialized == 'true'
        continue-on-error: true
        env:
          NAV_LANDLORD_URL: ${{ vars.STAGE_NAV_LANDLORD_URL }}
          NAV_TENANT_URL: ${{ vars.STAGE_NAV_TENANT_URL }}
          PLAYWRIGHT_IGNORE_HTTPS_ERRORS: ${{ env.PLAYWRIGHT_IGNORE_HTTPS_ERRORS }}
        run: npm run test:navigation
        working-directory: web-app

      - name: Mark stage revision as successful after navigation smoke
        if: steps.stage_navigation_smoke.outcome == 'success' || steps.stage_initialize_preflight.outputs.initialized != 'true'
        env:
          DEPLOY_SSH_HOST: ${{ vars.STAGE_SSH_HOST }}
          DEPLOY_SSH_PORT: ${{ vars.STAGE_SSH_PORT }}
          DEPLOY_SSH_USER: ${{ vars.STAGE_SSH_USER }}
          DEPLOY_PATH: ${{ vars.STAGE_DEPLOY_PATH }}
          DEPLOY_SSH_KEY_PATH: ~/.ssh/id_ed25519_stage
        run: bash .github/scripts/mark_successful_revision_over_ssh.sh

      - name: Roll back stage deploy when navigation smoke fails
        if: steps.stage_navigation_smoke.outcome == 'failure'
        env:
          DEPLOY_LANE: stage
          DEPLOY_SSH_HOST: ${{ vars.STAGE_SSH_HOST }}
          DEPLOY_SSH_PORT: ${{ vars.STAGE_SSH_PORT }}
          DEPLOY_SSH_USER: ${{ vars.STAGE_SSH_USER }}
          DEPLOY_PATH: ${{ vars.STAGE_DEPLOY_PATH }}
          DEPLOY_NGINX_HOST_PORT_80: ${{ vars.STAGE_NGINX_HOST_PORT_80 }}
          DEPLOY_NGINX_HOST_PORT_443: ${{ vars.STAGE_NGINX_HOST_PORT_443 }}
          DEPLOY_HEALTH_HOST: ${{ vars.STAGE_NAV_LANDLORD_URL }}
          DEPLOY_SSH_KEY_PATH: ~/.ssh/id_ed25519_stage
          SUBMODULES_REPO_TOKEN: ${{ steps.submodule_auth.outputs.token }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          GITHUB_REF_NAME: ${{ github.ref_name }}
          ROLLBACK_TARGET_REVISION: ${{ steps.stage_rollback_target.outputs.revision }}
        run: bash .github/scripts/rollback_over_ssh.sh

      - name: Fail stage deploy after rollback
        if: steps.stage_navigation_smoke.outcome == 'failure'
        run: |
          echo "ERROR: stage navigation smoke failed; rollback executed." >&2
          exit 1

  deploy_main:
    name: Deploy Production
    runs-on: ubuntu-latest
    needs:
      - preflight
      - promote_source_repos
    if: ${{ github.event_name == 'push' && github.ref_name == 'main' && needs.preflight.result == 'success' && needs.promote_source_repos.result == 'success' }}
    environment: production

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Resolve submodule checkout auth
        id: submodule_auth
        env:
          SUBMODULES_REPO_TOKEN: ${{ secrets.SUBMODULES_REPO_TOKEN }}
          WEB_APP_REPO_TOKEN: ${{ secrets.WEB_APP_REPO_TOKEN }}
        run: |
          token="${SUBMODULES_REPO_TOKEN:-}"
          if [[ -z "$token" ]]; then
            token="${WEB_APP_REPO_TOKEN:-}"
          fi

          if [[ -n "$token" ]]; then
            echo "::add-mask::$token"
            echo "has_token=true" >> "$GITHUB_OUTPUT"
            echo "token=$token" >> "$GITHUB_OUTPUT"
          else
            echo "has_token=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Checkout submodules
        if: steps.submodule_auth.outputs.has_token == 'true'
        env:
          SUBMODULE_TOKEN: ${{ steps.submodule_auth.outputs.token }}
        run: |
          git config --global --unset-all url.https://github.com/.insteadOf || true
          git config --global url."https://x-access-token:${SUBMODULE_TOKEN}@github.com/".insteadOf "https://github.com/"
          git submodule sync --recursive
          git submodule update --init --recursive

      - name: Fail when missing submodule token
        if: steps.submodule_auth.outputs.has_token != 'true'
        run: |
          echo "ERROR: missing required secret for private submodule checkout." >&2
          echo "Set SUBMODULES_REPO_TOKEN (recommended) or WEB_APP_REPO_TOKEN in this repository secrets." >&2
          exit 1

      - name: Configure SSH private key
        env:
          MAIN_SSH_PRIVATE_KEY: ${{ secrets.MAIN_SSH_PRIVATE_KEY }}
        run: |
          if [[ -z "${MAIN_SSH_PRIVATE_KEY:-}" ]]; then
            echo "ERROR: missing required secret MAIN_SSH_PRIVATE_KEY." >&2
            exit 1
          fi

          install -m 700 -d ~/.ssh
          printf '%s\n' "$MAIN_SSH_PRIVATE_KEY" > ~/.ssh/id_ed25519_main
          chmod 600 ~/.ssh/id_ed25519_main

      - name: Configure known hosts
        env:
          MAIN_SSH_KNOWN_HOSTS: ${{ secrets.MAIN_SSH_KNOWN_HOSTS }}
        run: |
          if [[ -z "${MAIN_SSH_KNOWN_HOSTS:-}" ]]; then
            echo "ERROR: missing required secret MAIN_SSH_KNOWN_HOSTS." >&2
            exit 1
          fi

          install -m 700 -d ~/.ssh
          printf '%s\n' "$MAIN_SSH_KNOWN_HOSTS" > ~/.ssh/known_hosts
          chmod 600 ~/.ssh/known_hosts

      - name: Capture production rollback target revision
        id: main_rollback_target
        env:
          DEPLOY_SSH_HOST: ${{ vars.MAIN_SSH_HOST }}
          DEPLOY_SSH_PORT: ${{ vars.MAIN_SSH_PORT }}
          DEPLOY_SSH_USER: ${{ vars.MAIN_SSH_USER }}
          DEPLOY_PATH: ${{ vars.MAIN_DEPLOY_PATH }}
          DEPLOY_SSH_KEY_PATH: ~/.ssh/id_ed25519_main
        run: |
          set -euo pipefail

          target="$(
            ssh -p "${DEPLOY_SSH_PORT}" -i "${DEPLOY_SSH_KEY_PATH}" \
              -o BatchMode=yes -o IdentitiesOnly=yes -o StrictHostKeyChecking=yes \
              "${DEPLOY_SSH_USER}@${DEPLOY_SSH_HOST}" "set -euo pipefail; if [[ -d '${DEPLOY_PATH}/.git' ]]; then cd '${DEPLOY_PATH}'; if [[ -f '.last_successful_revision' ]]; then cat '.last_successful_revision'; elif git rev-parse --verify HEAD >/dev/null 2>&1; then git rev-parse HEAD; fi; fi"
          )"

          target="$(echo "$target" | tr -d '[:space:]')"
          if [[ -n "$target" ]]; then
            echo "revision=$target" >> "$GITHUB_OUTPUT"
            echo "INFO: production rollback target revision captured: $target"
          else
            echo "INFO: production rollback target revision unavailable (first deployment path or no git HEAD)."
          fi

      - name: Deploy pinned production stack over SSH
        env:
          DEPLOY_LANE: main
          DEPLOY_SSH_HOST: ${{ vars.MAIN_SSH_HOST }}
          DEPLOY_SSH_PORT: ${{ vars.MAIN_SSH_PORT }}
          DEPLOY_SSH_USER: ${{ vars.MAIN_SSH_USER }}
          DEPLOY_PATH: ${{ vars.MAIN_DEPLOY_PATH }}
          DEPLOY_NGINX_HOST_PORT_80: ${{ vars.MAIN_NGINX_HOST_PORT_80 }}
          DEPLOY_NGINX_HOST_PORT_443: ${{ vars.MAIN_NGINX_HOST_PORT_443 }}
          DEPLOY_HEALTH_HOST: ${{ vars.MAIN_NAV_LANDLORD_URL }}
          DEPLOY_SSH_KEY_PATH: ~/.ssh/id_ed25519_main
          SUBMODULES_REPO_TOKEN: ${{ steps.submodule_auth.outputs.token }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          GITHUB_REF_NAME: ${{ github.ref_name }}
        run: bash .github/scripts/deploy_stage_over_ssh.sh

      - name: Validate production navigation targets configuration
        run: |
          if [[ -z "${{ vars.MAIN_NAV_LANDLORD_URL }}" || -z "${{ vars.MAIN_NAV_TENANT_URL }}" ]]; then
            echo "ERROR: missing production navigation variables MAIN_NAV_LANDLORD_URL/MAIN_NAV_TENANT_URL." >&2
            exit 1
          fi

      - name: Preflight production initialization status
        id: main_initialize_preflight
        env:
          NAV_LANDLORD_URL: ${{ vars.MAIN_NAV_LANDLORD_URL }}
          NAV_ORIGIN_IP: ${{ vars.MAIN_SSH_HOST }}
        run: |
          set -euo pipefail

          landlord="${NAV_LANDLORD_URL%/}"
          initialize_url="${landlord}/api/v1/initialize"
          landlord_host="$(python3 -c 'import sys, urllib.parse; print((urllib.parse.urlparse(sys.argv[1]).hostname or "").strip())' "$landlord")"
          if [[ -z "$landlord_host" ]]; then
            echo "ERROR: could not parse production landlord host from NAV_LANDLORD_URL." >&2
            exit 1
          fi

          curl_args=()
          if [[ -n "${NAV_ORIGIN_IP:-}" ]]; then
            curl_args+=(--resolve "${landlord_host}:443:${NAV_ORIGIN_IP}")
            curl_args+=(--insecure)
            echo "INFO: production initialization preflight routed directly to origin ${NAV_ORIGIN_IP}."
          fi

          echo "INFO: checking production initialization status at ${initialize_url}"
          status="$(curl -sS -m 15 "${curl_args[@]}" -o /tmp/main_initialize_response.json -w '%{http_code}' "${initialize_url}")"

          case "${status}" in
            200)
              echo "initialized=true" >> "$GITHUB_OUTPUT"
              ;;
            403)
              echo "initialized=false" >> "$GITHUB_OUTPUT"
              echo "::warning title=Production not initialized::Skipping navigation smoke because /api/v1/initialize returned HTTP 403."
              cat /tmp/main_initialize_response.json || true
              ;;
            *)
              echo "ERROR: unexpected production initialization status ${status}. Expected 200 or 403." >&2
              cat /tmp/main_initialize_response.json >&2 || true
              exit 1
              ;;
          esac

      - name: Skip production navigation smoke (environment not initialized)
        if: steps.main_initialize_preflight.outputs.initialized != 'true'
        run: |
          echo "INFO: skipping production navigation smoke because environment is not initialized yet."

      - name: Setup Node.js for real navigation smoke
        if: steps.main_initialize_preflight.outputs.initialized == 'true'
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: npm
          cache-dependency-path: web-app/package-lock.json

      - name: Install web navigation dependencies
        if: steps.main_initialize_preflight.outputs.initialized == 'true'
        run: npm ci
        working-directory: web-app

      - name: Install Playwright browser
        if: steps.main_initialize_preflight.outputs.initialized == 'true'
        run: npx playwright install --with-deps chromium
        working-directory: web-app

      - name: Route production smoke hosts directly to origin
        if: steps.main_initialize_preflight.outputs.initialized == 'true'
        env:
          NAV_LANDLORD_URL: ${{ vars.MAIN_NAV_LANDLORD_URL }}
          NAV_TENANT_URL: ${{ vars.MAIN_NAV_TENANT_URL }}
          NAV_ORIGIN_IP: ${{ vars.MAIN_SSH_HOST }}
        run: |
          set -euo pipefail

          parse_host() {
            local input_url="$1"
            python3 -c 'import sys, urllib.parse; print((urllib.parse.urlparse(sys.argv[1]).hostname or "").strip())' "$input_url"
          }

          landlord_host="$(parse_host "$NAV_LANDLORD_URL")"
          tenant_host="$(parse_host "$NAV_TENANT_URL")"

          if [[ -z "$landlord_host" || -z "$tenant_host" ]]; then
            echo "ERROR: could not parse production landlord/tenant hosts from navigation URLs." >&2
            exit 1
          fi

          if [[ -n "${NAV_ORIGIN_IP:-}" ]]; then
            {
              echo "${NAV_ORIGIN_IP} ${landlord_host}"
              echo "${NAV_ORIGIN_IP} ${tenant_host}"
            } | sudo tee -a /etc/hosts >/dev/null
            echo "PLAYWRIGHT_IGNORE_HTTPS_ERRORS=true" >> "$GITHUB_ENV"
            echo "INFO: production smoke mapped ${landlord_host}/${tenant_host} to ${NAV_ORIGIN_IP}."
          else
            echo "PLAYWRIGHT_IGNORE_HTTPS_ERRORS=false" >> "$GITHUB_ENV"
            echo "INFO: production smoke using public DNS resolution."
          fi

      - name: Run production real navigation smoke
        id: production_navigation_smoke
        if: steps.main_initialize_preflight.outputs.initialized == 'true'
        continue-on-error: true
        env:
          NAV_LANDLORD_URL: ${{ vars.MAIN_NAV_LANDLORD_URL }}
          NAV_TENANT_URL: ${{ vars.MAIN_NAV_TENANT_URL }}
          PLAYWRIGHT_IGNORE_HTTPS_ERRORS: ${{ env.PLAYWRIGHT_IGNORE_HTTPS_ERRORS }}
        run: npm run test:navigation
        working-directory: web-app

      - name: Mark production revision as successful after navigation smoke
        if: steps.production_navigation_smoke.outcome == 'success' || steps.main_initialize_preflight.outputs.initialized != 'true'
        env:
          DEPLOY_SSH_HOST: ${{ vars.MAIN_SSH_HOST }}
          DEPLOY_SSH_PORT: ${{ vars.MAIN_SSH_PORT }}
          DEPLOY_SSH_USER: ${{ vars.MAIN_SSH_USER }}
          DEPLOY_PATH: ${{ vars.MAIN_DEPLOY_PATH }}
          DEPLOY_SSH_KEY_PATH: ~/.ssh/id_ed25519_main
        run: bash .github/scripts/mark_successful_revision_over_ssh.sh

      - name: Roll back production deploy when navigation smoke fails
        if: steps.production_navigation_smoke.outcome == 'failure'
        env:
          DEPLOY_LANE: main
          DEPLOY_SSH_HOST: ${{ vars.MAIN_SSH_HOST }}
          DEPLOY_SSH_PORT: ${{ vars.MAIN_SSH_PORT }}
          DEPLOY_SSH_USER: ${{ vars.MAIN_SSH_USER }}
          DEPLOY_PATH: ${{ vars.MAIN_DEPLOY_PATH }}
          DEPLOY_NGINX_HOST_PORT_80: ${{ vars.MAIN_NGINX_HOST_PORT_80 }}
          DEPLOY_NGINX_HOST_PORT_443: ${{ vars.MAIN_NGINX_HOST_PORT_443 }}
          DEPLOY_HEALTH_HOST: ${{ vars.MAIN_NAV_LANDLORD_URL }}
          DEPLOY_SSH_KEY_PATH: ~/.ssh/id_ed25519_main
          SUBMODULES_REPO_TOKEN: ${{ steps.submodule_auth.outputs.token }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          GITHUB_REF_NAME: ${{ github.ref_name }}
          ROLLBACK_TARGET_REVISION: ${{ steps.main_rollback_target.outputs.revision }}
        run: bash .github/scripts/rollback_over_ssh.sh

      - name: Fail production deploy after rollback
        if: steps.production_navigation_smoke.outcome == 'failure'
        run: |
          echo "ERROR: production navigation smoke failed; rollback executed." >&2
          exit 1
