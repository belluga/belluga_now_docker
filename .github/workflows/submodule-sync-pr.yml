name: Sync Submodule Pins PR

on:
  repository_dispatch:
    types:
      - submodule-updated
  workflow_dispatch:
    inputs:
      submodule:
        description: "Submodule path in this repo (flutter-app or laravel-app)"
        required: true
        type: string
      sha:
        description: "Target commit SHA in that submodule repo"
        required: true
        type: string
      lane:
        description: "Target lane/base branch in docker repo (dev only for automatic sync)"
        required: false
        default: dev
        type: string
      flutter_sha:
        description: "Optional: full flutter-app SHA that produced the web artifact"
        required: false
        type: string
      source_repo:
        description: "Optional: source repo that triggered this sync (for PR body)"
        required: false
        type: string
      source_branch:
        description: "Optional: source branch that triggered this sync (for PR body)"
        required: false
        type: string

permissions:
  contents: write
  pull-requests: write

concurrency:
  group: docker-submodule-sync-${{ github.event.client_payload.lane || github.event.client_payload.source_branch || inputs.lane || 'dev' }}
  cancel-in-progress: false

jobs:
  sync:
    name: Open/Update PR Syncing Submodule Pins
    runs-on: ubuntu-latest

    steps:
      - name: Resolve inputs
        id: inputs
        env:
          DISPATCH_SUBMODULE: ${{ github.event.client_payload.submodule }}
          DISPATCH_SHA: ${{ github.event.client_payload.sha }}
          DISPATCH_LANE: ${{ github.event.client_payload.lane }}
          DISPATCH_FLUTTER_SHA: ${{ github.event.client_payload.flutter_sha }}
          DISPATCH_SOURCE_REPO: ${{ github.event.client_payload.source_repo }}
          DISPATCH_SOURCE_BRANCH: ${{ github.event.client_payload.source_branch }}
          INPUT_SUBMODULE: ${{ inputs.submodule }}
          INPUT_SHA: ${{ inputs.sha }}
          INPUT_LANE: ${{ inputs.lane }}
          INPUT_FLUTTER_SHA: ${{ inputs.flutter_sha }}
          INPUT_SOURCE_REPO: ${{ inputs.source_repo }}
          INPUT_SOURCE_BRANCH: ${{ inputs.source_branch }}
        run: |
          set -euo pipefail

          if [[ "${GITHUB_EVENT_NAME}" == "repository_dispatch" ]]; then
            submodule="${DISPATCH_SUBMODULE:-}"
            sha="${DISPATCH_SHA:-}"
            lane="${DISPATCH_LANE:-${DISPATCH_SOURCE_BRANCH:-}}"
            flutter_sha="${DISPATCH_FLUTTER_SHA:-}"
            source_repo="${DISPATCH_SOURCE_REPO:-}"
            source_branch="${DISPATCH_SOURCE_BRANCH:-}"
          else
            submodule="${INPUT_SUBMODULE:-}"
            sha="${INPUT_SHA:-}"
            lane="${INPUT_LANE:-}"
            flutter_sha="${INPUT_FLUTTER_SHA:-}"
            source_repo="${INPUT_SOURCE_REPO:-}"
            source_branch="${INPUT_SOURCE_BRANCH:-}"
          fi

          if [[ -z "$submodule" || -z "$sha" ]]; then
            echo "ERROR: missing required submodule/sha." >&2
            exit 1
          fi

          if [[ -z "$lane" ]]; then
            lane="dev"
          fi

          skip="false"
          skip_reason=""

          case "$lane" in
            dev|stage|main) ;;
            *)
              echo "ERROR: unsupported lane '$lane'. Allowed lanes: dev, stage, main." >&2
              exit 1
              ;;
          esac

          case "$submodule" in
            flutter-app|laravel-app) ;;
            *)
              skip="true"
              skip_reason="unsupported submodule '$submodule' (automatic sync supports only flutter-app and laravel-app)"
              ;;
          esac

          if [[ "$skip" != "true" && "$lane" != "dev" ]]; then
            skip="true"
            skip_reason="automatic submodule sync is restricted to lane 'dev' (received lane='$lane')"
          fi

          bot_branch="bot/submodule-sync-${lane}-${submodule}-${GITHUB_RUN_ID}"

          echo "submodule=$submodule" >> "$GITHUB_OUTPUT"
          echo "sha=$sha" >> "$GITHUB_OUTPUT"
          echo "lane=$lane" >> "$GITHUB_OUTPUT"
          echo "flutter_sha=$flutter_sha" >> "$GITHUB_OUTPUT"
          echo "bot_branch=$bot_branch" >> "$GITHUB_OUTPUT"
          echo "source_repo=$source_repo" >> "$GITHUB_OUTPUT"
          echo "source_branch=$source_branch" >> "$GITHUB_OUTPUT"
          echo "skip=$skip" >> "$GITHUB_OUTPUT"
          echo "skip_reason=$skip_reason" >> "$GITHUB_OUTPUT"

      - name: Skip unsupported dispatch
        if: steps.inputs.outputs.skip == 'true'
        run: |
          echo "INFO: skipping submodule sync dispatch: ${{ steps.inputs.outputs.skip_reason }}"

      - name: Checkout docker repo
        if: steps.inputs.outputs.skip != 'true'
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Configure private submodule auth
        if: steps.inputs.outputs.skip != 'true'
        env:
          SUBMODULES_REPO_TOKEN: ${{ secrets.SUBMODULES_REPO_TOKEN }}
        run: |
          set -euo pipefail
          if [[ -z "${SUBMODULES_REPO_TOKEN:-}" ]]; then
            echo "ERROR: missing required secret SUBMODULES_REPO_TOKEN." >&2
            exit 1
          fi
          echo "::add-mask::$SUBMODULES_REPO_TOKEN"
          # Avoid forcing GITHUB_TOKEN auth for subsequent git pushes. We want
          # to use the PAT so synchronize events can trigger downstream PR CI.
          git config --local --unset-all http.https://github.com/.extraheader || true
          git config --global --unset-all url.https://github.com/.insteadOf || true
          git config --global url."https://x-access-token:${SUBMODULES_REPO_TOKEN}@github.com/".insteadOf "https://github.com/"

      - name: Create/update bot branch from lane base
        if: steps.inputs.outputs.skip != 'true'
        env:
          BASE_BRANCH: ${{ steps.inputs.outputs.lane }}
          BOT_BRANCH: ${{ steps.inputs.outputs.bot_branch }}
        run: |
          set -euo pipefail
          git fetch origin "$BASE_BRANCH" --quiet
          git checkout -B "$BOT_BRANCH" "origin/$BASE_BRANCH"

      - name: Update submodule pin
        if: steps.inputs.outputs.skip != 'true'
        env:
          SUBMODULE: ${{ steps.inputs.outputs.submodule }}
          TARGET_SHA: ${{ steps.inputs.outputs.sha }}
        run: |
          set -euo pipefail

          case "$SUBMODULE" in
            flutter-app|laravel-app) ;;
            *)
              echo "ERROR: unsupported submodule '$SUBMODULE'." >&2
              echo "Allowed: flutter-app, laravel-app" >&2
              exit 1
              ;;
          esac

          git submodule sync --recursive

          # Ensure submodule is present at the currently pinned gitlink so we can
          # compare build metadata before/after updating the pin.
          git submodule update --init --recursive "$SUBMODULE"

          git -C "$SUBMODULE" fetch origin --prune --quiet
          git -C "$SUBMODULE" checkout --detach "$TARGET_SHA"

          git add "$SUBMODULE"

      - name: Commit changes (if any)
        if: steps.inputs.outputs.skip != 'true'
        id: commit
        env:
          SUBMODULE: ${{ steps.inputs.outputs.submodule }}
          TARGET_SHA: ${{ steps.inputs.outputs.sha }}
        run: |
          set -euo pipefail

          # Submodules are configured with ignore=all in this repository.
          # Force diff to consider staged gitlink updates; otherwise this
          # check can incorrectly report "no changes" for submodule pin bumps.
          if git diff --cached --ignore-submodules=none --quiet; then
            echo "no_changes=true" >> "$GITHUB_OUTPUT"
            echo "INFO: no gitlink changes to commit."
            exit 0
          fi

          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

          short_sha="$(echo "$TARGET_SHA" | cut -c1-7)"
          git commit -m "ðŸ”— chore(submodules): sync ${SUBMODULE} pin to ${short_sha}"
          echo "no_changes=false" >> "$GITHUB_OUTPUT"

      - name: Push bot branch
        if: steps.inputs.outputs.skip != 'true' && steps.commit.outputs.no_changes != 'true'
        env:
          BOT_BRANCH: ${{ steps.inputs.outputs.bot_branch }}
        run: |
          set -euo pipefail
          # Bot branches are lane-scoped and intentionally rewritten on each sync.
          # Force-with-lease avoids non-fast-forward failures while still protecting
          # against unexpected remote updates.
          git push --force-with-lease -u origin "$BOT_BRANCH"

      - name: Close superseded sync PRs for same lane/submodule
        if: steps.inputs.outputs.skip != 'true' && steps.commit.outputs.no_changes != 'true'
        env:
          GH_TOKEN: ${{ secrets.SUBMODULES_REPO_TOKEN || secrets.WEB_APP_REPO_TOKEN || github.token }}
          BASE_BRANCH: ${{ steps.inputs.outputs.lane }}
          BOT_BRANCH: ${{ steps.inputs.outputs.bot_branch }}
          SUBMODULE: ${{ steps.inputs.outputs.submodule }}
        run: |
          set -euo pipefail

          prefix="bot/submodule-sync-${BASE_BRANCH}-${SUBMODULE}-"
          superseded="$(
            gh pr list \
              --repo "$GITHUB_REPOSITORY" \
              --state open \
              --base "$BASE_BRANCH" \
              --json number,headRefName \
              --jq ".[] | select((.headRefName | startswith(\"${prefix}\")) and (.headRefName != \"${BOT_BRANCH}\")) | .number"
          )"

          if [[ -z "${superseded}" ]]; then
            echo "INFO: no superseded sync PRs for ${SUBMODULE} on lane ${BASE_BRANCH}."
            exit 0
          fi

          while IFS= read -r pr_number; do
            if [[ -z "${pr_number}" ]]; then
              continue
            fi
            gh pr close "${pr_number}" \
              --repo "$GITHUB_REPOSITORY" \
              --comment "Superseded by ${BOT_BRANCH} for ${SUBMODULE} on lane ${BASE_BRANCH}."
          done <<< "${superseded}"

      - name: Create or update PR into lane base
        if: steps.inputs.outputs.skip != 'true' && steps.commit.outputs.no_changes != 'true'
        env:
          # Some repositories disable "Allow GitHub Actions to create pull requests".
          # Use the PAT secret (already required for private submodule checkout) so
          # PR creation works regardless of that repository setting.
          GH_TOKEN: ${{ secrets.SUBMODULES_REPO_TOKEN || secrets.WEB_APP_REPO_TOKEN || github.token }}
          BASE_BRANCH: ${{ steps.inputs.outputs.lane }}
          BOT_BRANCH: ${{ steps.inputs.outputs.bot_branch }}
          SUBMODULE: ${{ steps.inputs.outputs.submodule }}
          TARGET_SHA: ${{ steps.inputs.outputs.sha }}
          LANE: ${{ steps.inputs.outputs.lane }}
          SOURCE_REPO: ${{ steps.inputs.outputs.source_repo }}
          SOURCE_BRANCH: ${{ steps.inputs.outputs.source_branch }}
        run: |
          set -euo pipefail

          short_sha="$(echo "$TARGET_SHA" | cut -c1-7)"
          title="ðŸ”— chore(submodules): sync ${SUBMODULE} pin (${short_sha}) [${LANE}]"

          body=$'Automated submodule pin sync.\n\n- Lane: '"${LANE}"$'\n- Submodule: '"${SUBMODULE}"$'\n- Commit: '"${TARGET_SHA}"$'\n'
          if [[ -n "${SOURCE_REPO}" ]]; then
            body="${body}"$'\n'"- Source repo: ${SOURCE_REPO}"
          fi
          if [[ -n "${SOURCE_BRANCH}" ]]; then
            body="${body}"$'\n'"- Source branch: ${SOURCE_BRANCH}"
          fi

          existing="$(gh pr list --repo "$GITHUB_REPOSITORY" --base "$BASE_BRANCH" --head "$BOT_BRANCH" --json number --jq '.[0].number // empty')"
          if [[ -n "$existing" ]]; then
            gh pr edit "$existing" --repo "$GITHUB_REPOSITORY" --title "$title" --body "$body"
            echo "INFO: updated existing PR #$existing"
            exit 0
          fi

          gh pr create \
            --repo "$GITHUB_REPOSITORY" \
            --base "$BASE_BRANCH" \
            --head "$BOT_BRANCH" \
            --title "$title" \
            --body "$body"
